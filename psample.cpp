// Original matlab code from http://labrosa.ee.columbia.edu/matlab/pvoc/
// c = pvsample(b, t, hop)   Interpolate an STFT array according to the 'phase vocoder'
//     b is an STFT array, of the form generated by 'specgram'.
//     t is a vector of (real) time-samples, which specifies a path through
//     the time-base defined by the columns of b.  For each value of t,
//     the spectral magnitudes in the columns of b are interpolated, and
//     the phase difference between the successive columns of b is
//     calculated; a new column is created in the output array c that
//     preserves this per-step phase advance in each bin.
//     hop is the STFT hop size, defaults to N/2, where N is the FFT size
//     and b has N/2+1 rows.  hop is needed to calculate the 'null' phase
//     advance expected in each bin.
//     Note: t is defined relative to a zero origin, so 0.1 is 90// of
//     the first column of b, plus 10// of the second.

#include "stft.h"
#define _USE_MATH_DEFINES
#include <math.h>
#include <complex>
#include <stdlib.h>
#include <QDebug>
#include <opencv/cv.h>
#include "opencv2/opencv.hpp"
#include "opencv2/core/core.hpp"
#include "ploter.h"

extern Ploter* p;
extern Ploter* p2;

double* zeroes(int i1, int i2);
complex_double** Make2DArray(int arraySizeX, int arraySizeY);

double angle(complex_double d)
{
    std::complex<double> cd(d.re,d.im);
    return arg(cd);
    //return atan2(d.im,d.re);
}

double mag(complex_double d)
{
    std::complex<double> cd(d.re,d.im);
    return abs(cd);
}

int round(double x)
{
    if (x < 0.0)
        return (int)(x - 0.5);
    else
        return (int)(x + 0.5);
}


complex_double** some_filter(complex_double** b, int rows, int cols)
{
    double dphi=0;
    double T = rows / 10.; // 10 колебаний за весь период
    p2->clearvals(0);

    double maxA=0;

    cv::Mat src(rows, cols, CV_32F);
    int x,y;
    for(int i=0; i < rows; i++)
    for(int j=0; j < cols; j++)
    {
        float A = mag(b[i][j])/60.;
        //circle(src, cv::Point(i,j), 5, col, 1);
        *(float*)src.ptr(i,j) = A;
    }

    cv::Mat gauss(rows, cols, CV_32F);
    //medianBlur(src, gauss, 7);

    int erosion_size = 7;
    cv::Mat element = getStructuringElement( cv::MORPH_ELLIPSE,
                                         cv::Size( 2*erosion_size + 1, 2*erosion_size+1 ),
                                         cv::Point( erosion_size, erosion_size ) );

    /// Apply the erosion operation
    erode( src, gauss, element );
    //cv::threshold(gauss, src, 0.0009, 0, cv::THRESH_TOZERO_INV);

    for(int i=0; i<rows; i++)
    {
        for(int j=0; j<cols; j++)
        {
            double A;

            A = *(float*)gauss.ptr(i,j)*1000;//mag(b[i][j]);
            maxA = qMax(maxA,mag(b[i][j]));

            double ph = angle(b[i][j]);
            //if(j>cols/2)
            if(i==5)
            {
              p2->setXY(0,j,A);
              p2->setXY(1,j,mag(b[i][j])/12.);
            }
            //A = mag(b[i][j]);
            //Save the column
            b[i][j].re = A * cos(ph);
            b[i][j].im = A * sin(ph);
        }
        //dphi = sin((2 * M_PI / T)*i);

    }
    p2->update_data();
    return b;
}

complex_double** pvsample(complex_double** b, double* t, int size_t, double hop, int rows, int cols, int* ocols)
{   
    int N = 2*(rows-1);

    if(hop == 0)
      hop = N/2;

    // Empty output array
    complex_double** c = Make2DArray(rows, size_t);

    //Expected phase advance in each bin
    double* dphi = zeroes(1,N/2+1);

    for(int i=0; i < rows; i++)
      dphi[i] = ((double)2*M_PI*hop)/((double)N/(double)i);

    dphi[0] = 0;

    // Phase accumulator
    // Preset to phase of first frame for perfect reconstruction
    // in case of 1:1 time scaling
    double* ph = zeroes(1,rows);
    for(int i=0; i < rows; i++)
      ph[i] = angle(b[i][0]);
    double* bcol1 = zeroes(1,rows);
    double* bcol2 = zeroes(1,rows);
    double* bcol1a = zeroes(1,rows);
    double* bcol2a = zeroes(1,rows);
    double* bmag  = zeroes(1,rows);
    double* dp  = zeroes(1,rows);
    *ocols=0;


    for(int i=0; i < size_t; i++)
    {
        double tt = t[i];

        //if(tt+2 > cols)
        //    break;

        // Grab the two columns of b
        for(int j=0; j < rows; j++)
        {
            bcol1[j] = mag(b[j][(int)tt]);
            bcol2[j] = mag(b[j][(int)tt+1]);
            bcol1a[j] = angle(b[j][(int)tt]);
            bcol2a[j] = angle(b[j][(int)tt+1]);
        }
        double tf = tt - floor(tt);

        //qDebug("tf=%f",tf);

        for(int j=0; j < rows; j++)
        {

           bmag[j] = (1-tf)*(bcol1[j]) + tf*(bcol2[j]);
           // calculate phase advance
           dp[j] = bcol2a[j] - bcol1a[j] - dphi[j];

           // Reduce to -pi:pi range
           dp[j] = dp[j] - 2 * M_PI * round(dp[j]/(2*M_PI));

           //Save the column
           c[j][i].re = bmag[j] * cos(ph[j]);
           c[j][i].im = bmag[j] * sin(ph[j]);

           //Cumulate phase, ready for next frame
            ph[j] = ph[j] + dphi[j] + dp[j];

        }
        (*ocols)++;
    }
    //free(dphi);
    //free(ph);
    //free(bcol1);
    //free(bcol2);
    //free(bcol1a);
    //free(bcol2a);
    //free(bmag);
    //free(dp);
    return c;
}
